
// Character Classes
letter = _{ ASCII_ALPHA }
digit = _{ ASCII_DIGIT }
posDigit = _{ '1'..'9' }
posDigitFrom2 = _{ '2'..'9' }
hexdigit = _{ digit | 'a'..'f' | 'A'..'F' }
special = _{ "\'" | "_" | "?" }

cr = _{ "\r" }
lf = _{ "\n" }
tab = _{ "\t" }
space = _{ " " }
WHITESPACE = _{ space | tab | cr | lf }

COMMENT = _{ "//" ~ (!lf ~ ANY)* ~ lf | "/*" ~ (!("*/") ~ ANY)* ~ "*/" }

nondigitIdChar = _{ letter | special }
idchar = _{ nondigitIdChar | digit }
nonidchar = _{ !idchar ~ ANY }

charChar = _{ !("\'" | "\\" | cr | lf ) ~ ANY }
stringChar = _{ !("\"" | "\\" | cr | lf ) ~ ANY }
verbatimStringChar = _{ !("\"") ~ ANY }

arrayToken = _{ "array" ~ (posDigitFrom2 | posDigit ~ digit ~ digit*)? ~ ("?")? }
bvToken = _{ "bv" ~ ("0" | posDigit ~ digit*) }
reservedword = _{ "abstract"| "allocated"| "as"| "assert"| "assume"|
  "bool"| "break"| "by"| 
  "calc"| "case"| "char"| "class"| "codatatype"|
  "colemma"| "const"| "constructor"| "copredicate"| 
  "datatype"| "decreases"|
  "else"| "ensures"| "exists"| "export"| "extends"|
  "false"| "forall"| "fresh"| "function"| "ghost"|
  "if"| "imap"| "import"| "in"| "include"| "inductive"|
  "int"| "invariant"| "is"| "iset"| "iterator"|
  "label"| "lemma"| "map"| "match"| "method"|
  "modifies"| "modify"| "module"| "multiset"| 
  "nameonly"| "nat"| "new"| "newtype"| "null"|
  "object"| "object?"| "old"| "opened"| "ORDINAL"|
  "predicate"| "print"| "provides"|
  "reads"| "real"| "refines"| "requires"| "return"|
  "returns"| "reveal"| "reveals"|
  "seq"| "set"| "static"| "string"| 
  "then"| "this"| "trait"| "true"| "twostate"| "type"|
  "unchanged"| "var"| "while"| "witness"|
  "yield"| "yields" | arrayToken | bvToken }

ident = _{ !(charToken | reservedword) ~ nondigitIdChar ~ idchar* }

digits = _{ digit ~ ("_"? ~ digit )* }
hexdigits = _{ "0x" ~ hexdigit ~ ("_"? ~ hexdigit )* }
decimaldigits = _{ digit ~ ("_"? ~ digit )* ~ "." ~ digit ~ ("_"? ~ digit )* }

escapedChar = _{ "\\\'" | "\\\"" | "\\\\" | "\\0" | "\\n" | "\\r" | "\\t" 
    | "\\u" ~ hexdigit{4} }

charToken = _{ "\'" ~ (charChar | escapedChar) ~ "\'" }
stringToken = _{
    ("\"" ~ (stringChar | escapedChar)* ~ "\"" )
    | ("@" ~ "\"" ~ (verbatimStringChar | "\'" ~ "\"")* ~ "\"" )
}

ellipsis = { "..." }

Ident = @{ ident }
DotSuffix = @{ ident | digits | "requires" | "reads" }
NoUSIdent = @{ !("_" ~ idchar*) ~ ident }
WildIdent = @{ NoUSIdent | "_" }

IdentOrDigits = @{ Ident | digits }
NoUSIdentOrDigits = @{ NoUSIdent | digits }
ModuleName = @{ NoUSIdent }
ClassName = @{ NoUSIdent }
DatatypeName = @{ NoUSIdent }
DatatypeMemberName = @{ NoUSIdentOrDigits }
NewtypeName = @{ NoUSIdent }
SynonymName = @{ NoUSIdent }
IteratorName = @{ NoUSIdent }
TypeVariableName = @{ NoUSIdent }
MethodFunctionName = @{ NoUSIdentOrDigits }
LabelName = @{ NoUSIdentOrDigits }
AttributeName = @{ NoUSIdent }
ExportId = @{ NoUSIdentOrDigits }
TypeNameOrCtorSuffix = @{ NoUSIdentOrDigits }

QualifiedModuleName = @{ ModuleName ~ ("." ~ ModuleName)* }

IdentType = { WildIdent ~ ":" ~ Type }
FIdentType = { NoUSIdentOrDigits ~ ":" ~ Type }
CIdentType = { NoUSIdentOrDigits ~ (":" ~ Type)? }
GIdentType = {
    ("ghost" | "new" | "nameonly")?
    ~ IdentType
    ~ (":=" ~ Expression)?
}
LocalIdentTypeOptional = { WildIdent ~ (":" ~ Type)? }
IdentTypeOptional = { WildIdent ~ (":" ~ Type)? }
TypeIdentOptional = { 
    ("ghost" | "nameonly")?
    ~ (NoUSIdentOrDigits ~ ":")? ~ Type
    ~ (":=" ~ Expression)?
}
FormalsOptionalIds = {
    "("
    ~ (
        TypeIdentOptional
        ~ ("," ~ TypeIdentOptional)*
    )?
    ~ ")"
}

Nat = { digits | hexdigits }
Dec = { decimaldigits }

// Programs
Dafny = { SOI ~ IncludeDirective_* ~ TopDecl* ~ EOI }
IncludeDirective_ = _{ "include" ~ stringToken }
TopDecl = {
    DeclModifier* ~ 
    (
        SubModuleDecl
/*        | ClassDecl
        | DatatypeDecl
        | NewtypeDecl
        | SynonymTypeDecl
        | IteratorDecl
        | TraitDecl
        | ClassMemberDecl */
    )
}

DeclModifier = @{ "abstract" | "ghost" | "static" }

SubModuleDecl = { ModuleDefinition
    | ModuleImport
    | ModuleExport
}

ModuleDefinition = { "module" ~ Attribute*
    ~ ModuleQualifiedName
    ~ ("refines" ~ ModuleQualifiedName)?
    ~ "{" ~ TopDecl* ~ "}"
}
ModuleQualifiedName = @{ ModuleName ~ ("." ~ ModuleName)* }

// The ordered choice's order is important
// If you put the A = B rule after QualifiedModuleExport, it will always match the first rule
ModuleImport = { "import" ~ "opened"? ~ (
    (ModuleName ~ "=" ~ QualifiedModuleExport)
    | (ModuleName ~ ":" ~ QualifiedModuleExport)
    | QualifiedModuleExport
) }
QualifiedModuleExport = { ModuleQualifiedName ~ ("`" ~ ModuleExportSuffix)? }
ModuleExportSuffix = { ExportId | "{" ~ ExportId ~ ("," ~ ExportId)* ~ "}" }

ModuleExport = {
    "export" ~ ExportId? ~ ellipsis? ~ (
        ("provides" ~ (
            (ExportSignature ~ ("," ~ ExportSignature)*) | "*"
        ))
        | ("reveals" ~ (
                (ExportSignature ~ ("," ~ ExportSignature)*) | "*"
            ))
        | ("extends" ~ ExportId ~ ("," ~ ExportId)*)
    )*
}
// TODO: Here
ExportSignature = { MethodFunctionName }

// Specifiaction Clauses
RequiresClause = { "requires" ~ Attribute* ~ (LabelName ~ ":")? ~ Expression }
EnsuresClause = { "ensures" ~ Attribute* ~ Expression }
DecreasesClause = { "decreases" ~ Attribute* ~ DecreasesList }
DecreasesList = {
    PossiblyWildExpression
    ~ ("," ~ PossiblyWildExpression)*
}
PossiblyWildExpression = { "*" | Expression }
FrameExpression = { Expression ~ FrameField? | FrameField }
FrameField = { "`" ~ IdentOrDigits }
PossiblyWildFrameExpression = { "*" | FrameExpression }
ReadsClause = { "reads" ~ Attribute?
    ~ PossiblyWildFrameExpression
    ~ ("," ~ PossiblyWildFrameExpression)*
}
ModifiesClause = { "modifies" ~ Attribute? ~ FrameExpression ~ ("," ~ FrameExpression)* }
InvariantClause_ = _{ "invariant" ~ Attribute* ~ Expression }

MethodSpec = { 
    (
        ModifiesClause
        | RequiresClause
        | EnsuresClause
        | DecreasesClause
    )*
 }

FucntionSpec = {
    (
        RequiresClause
        | ReadsClause
        | EnsuresClause
        | DecreasesClause
    )*
}

LambdaSpec = {
    (
        ReadsClause
        | RequiresClause
    )*
}

IteratorSpec = {
    (
        ReadsClause
        | ModifiesClause
        | "yields" ~ RequiresClause
        | "yield" ~ EnsuresClause
        | DecreasesClause
    )*
}

LoopSpec = {
    (
        InvariantClause_
        | DecreasesClause
        | ModifiesClause
    )*
}

// Types
Type = { DomainType_ | ArrowType_ }
DomainType_ = { 
    BoolType_ | CharType_ | IntType_ | RealType_
    | OrdinalType_ | BitVectorType_ | ObjectType_
    | FiniteSetType_ | InfiniteSetType_
    | MultisetType_
    | FiniteMapType_ | InfiniteMapType_
    | SequenceType_
    | NatType_
    | StringType_
    | ArrayType_
    | TupleType_
    | NamedType_
}

NamedType_ = { NameSegmentForTypeName ~ ("." ~ NameSegmentForTypeName)* }
NameSegmentForTypeName = { Ident ~ GenricInstantiation? }

// Basic Types
BoolType_ = { "bool" }
IntType_ = { "int" }
RealType_ = { "real" }
BitVectorType_ = { bvToken }
OrdinalType_ = { "ORDINAL" }
CharType_ = { "char" }

// Type Parameters
GenericParameters = {
    "<" ~ Variance?
    ~ TypeVariableName ~ TypeParameterCharacteristics*
    ~ ("," ~ Variance? ~ TypeVariableName ~ TypeParameterCharacteristics*)*
    ~ ">"
}
Variance = { "*" | "+" | "!" | "-" }
TypeParameterCharacteristics = {
    "(" ~ TPCharOption ~ ("," ~ TPCharOption)* ~ ")"
}
TPCharOption = { "==" | "0" | "00" | "!" ~ "new" }

// Genric Instantiation
GenericInstantiation = {
    "<" ~ Type ~ ("," ~ Type)* ~ ">"
}

// Collection Types
FiniteSetType_ = { "set" ~ GenericInstantiation? }
InfiniteSetType_ = { "iset" ~ GenericInstantiation? }
MultisetType_ = { "multiset" ~ GenericInstantiation? }
SequenceType_ = { "seq" ~ GenericInstantiation? }
StringType_ = { "string" } // is seq<char>
FiniteMapType_ = { "map" ~ GenericInstantiation? }
InfiniteMapType_ = { "imap" ~ GenericInstantiation? }

// Types that stand for other types
SynonymDecl = { SynonymTypeDecl_ | OpaqueTypeDecl_ | SubsetTypeDecl_ }
SynonymTypeName = @{ NoUSIdent }
SynonymTypeDecl_ = {
    "type" ~ Attribute* ~ SynonymTypeName
    ~ TypeParameterCharacteristics*
    ~ GenericParameters?
    ~ "=" ~ Type
}
OpaqueTypeDecl_ = {
    "type" ~ Attribute* ~ SynonymTypeName
    ~ TypeParameterCharacteristics*
    ~ GenericParameters?
    ~ TypeMembers?
}
TypeMembers = {
    "{" ~ (
        DeclModifier* ~ ClassMemberDecl
    )* ~ "}"
}

SubsetTypeDecl_ = {
    "type" ~ Attribute* ~ SynonymTypeName
    ~ GenericParameters?
    ~ "=" ~ LocalIdentTypeOptional
    ~ "|" ~ Expression
    ~ (
        "ghost" ~ "witness" ~ Expression
        | "witness" ~ Expression
        | "witness" ~ "*"
    )?
}
NatType_ = { "nat" }

// Newtypes
NewtypeDecl = {
    "newtype" ~ Attribute* ~ NewtypeName ~ "="
    ~ ellipsis? ~ (
        LocalIdentTypeOptional ~ "|" ~ Expression
        ~ (
            "ghost" ~ "witness" ~ Expression
            | "witness" ~ Expression
            | "witness" ~ "*"
        )?
        | Type
    ) ~ TypeMembers?
}

// Class Types
ClassDecl = {
    "class" ~ Attribute* ~ ClassName
    ~ GenericParameters?
    ~ ("extends" ~ Type ~ ("," ~ Type)* | ellipsis)?
    ~ "{" ~ (
        DeclModifier* ~ ClassMemberDecl
    )* ~ "}"
}
ClassMemberDecl = {
    FieldDecl
    | ConstantFieldDecl
    | FunctionDecl
    | MethodDecl
}
FieldDecl = { 
    "var" ~ Attribute* ~ FIdentType
    ~ ("," ~ FIdentType)*
}
ConstantFieldDecl = {
    "const" ~ Attribute* ~ CIdentType ~ ellipsis?
    ~ (":=" ~ Expression)?
}
MethodDecl = {
    MethodKeyword_ ~ Attribute* ~ MethodFunctionName?
    ~ (MethodSignature_ ~ ellipsis)
    ~ MethodSpec
    ~ BlockStmt?
}
MethodKeyword_ = {
    "method" | "constructor"
    | "lemma" | "twostate" ~ "lemma"
    | "least" ~ "lemma" | "greates" ~ "lemma"
}
MethodSignature_ = {
    GenericParameters? 
    ~ KType?
    ~ Formals
    ~ ("returns" ~ Formals)?
}
KType = { "[" ~ ("nat" | "ORDINAL") ~ "]" }
Formals = {
    "(" ~ (GIdentType ~ ("," ~ GIdentType)*)? ~ ")"
}

FunctionDecl = {
    (
        "twostate"? ~ "function" ~ "method"? ~ Attribute*
            ~ MethodFunctionName
            ~ FunctionSignatureOrEllipsis_
        | "predicate" ~ "method"? ~ Attribute*
            ~ MethodFunctionName
            ~ PredicateSignatureOrEllipsis_
        | ("least" | "greatest") ~ "predicate" ~ Attribute*
            ~ MethodFunctionName
            ~ PredicateSignatureOrEllipsis_
    )
    ~ FucntionSpec
    ~ FunctionBody?
}

FunctionSignatureOrEllipsis_ = {
    FunctionSignature_ | ellipsis
}
FunctionSignature_ = {
    GenericParameters?
    ~ Formals
    ~ ":"
    ~ (
        Type
        | "(" ~ GIdentType ~ ")"
    )
}
PredicateSignatureOrEllipsis_ = {
    PredicateSignature_ | ellipsis
}
PredicateSignature_ = {
    GenericParameters? ~ KType? ~ Formals
}
FucntionBody = {
    "{" ~ Expression ~ "}"
    ~ ("by" ~ "method" ~ BlockStmt)?
}

// Trait Types
TraitDecl = {
    "trait" ~ Attribute* ~ ClassName
    ~ ("extends" ~ Type ~ ("," ~ Type)* | ellipsis )?
    ~ "{" ~ (
        DeclModifier* ~ ClassMemberDecl
    )* ~ "}"
}
ObjectType_ = { "object" | "object?" }

// Array Types
ArrayType_ = { arrayToken ~ GenericInstantiation? }

// Iterator Types
// TODO: Here

// Expressions
Expression = { EquivExpression ~ (";" ~ Expression)? }
EquivExpression = { ImpliesExpression ~ ("<==>" ~ ImpliesExpression)* }
ImpliesExpliesExpression = {
    LogicalExpression ~ (
        "==>" ~ ImpliesExpression
        | "<==" ~ LogicalExpression ~ ("<==" ~ LogicalExpression)*
    )?
}
ImpliesExpression = { LogicalExpression ~ ("==>" ~ ImpliesExpression)? }
LogicalExpression = { 
    RelationalExpression ~ (
        "&&" ~ RelationalExpression ~ ("&&" ~ RelationalExpression)*
        | "||" ~ RelationalExpression ~ ("||" ~ RelationalExpression)*
    )?
    | ("&&" ~ RelationalExpression)*
    | ("||" ~ RelationalExpression)*
}
RelationalExpression = { ShiftTerm ~ (RelOp ~ ShiftTerm)* }
RelOp = { 
    "==" ~ (
        "#" ~ "[" ~ Expression ~ "]"
    )?
    | "!=" ~ (
        "#" ~ "[" ~ Expression ~ "]"
    )?
    |"<" | ">" | "<=" | ">="
    | "in" | "!in" | "!!"
}
ShiftTerm = { Term ~ (ShiftOp ~ Term)* }
ShiftOp = { "<<" | ">>" }
Term = { Factor ~ (AddOp ~ Factor)* }
AddOp = { "+" | "-" }
Factor = { BitvectorFactor ~ (MulOp ~ BitvectorFactor)* }
MulOp = { "*" | "/" | "%" }
BitvectorFactor = { AsExpression ~ (BVOp ~ AsExpression)* }
BVOp = { "&" | "|" | "^" }
AsExpression = { UnaryExpression ~ ("as" | "is") ~ Type }
UnaryExpression = { 
    "-" ~ UnaryExpression
    | "!" ~ UnaryExpression
    | PrimaryExpression
}

// TODO: Here
PrimaryExpression = { "*" }

/*
PrimaryExpression = {
    NameSegment ~ Suffix*
    | LambdaExpression
    | MapDisplayExpr ~ Suffix?
    | SeqDisplayExpr ~ Suffix?
    | SetDisplayExpr ~ Suffix?
    | EndlessExpression
    | ConstAtomExpression ~ Suffix?
}*/



// Attributes
Attribute = { "{:" ~ AttributeName ~ Expression? ~ ":}" }